## Слой Peer-to-Peer

Непосредственное сетевое взаимодействие (подключение, прием/передача сообщений) отдается на откуп базового фреймворка.
Сам же слой P2P представляет из себя Peer Sampling Service, службу, предоставляющую доступ только в некоторым узлам из всей сети БЧ.
Для работы алгоритма консенсуса необходима широковещательная рассылка сообщений, в случае же большого количества узлов, количество соединенных 
пар будет расти как функция квадрата. Кроме того топология связанного, но не полного графа положительно влияет на потребляемые коненсусом ресуры.

Идея состоит в следующем: узел поддерживает список соседних улов, с которыми установленна двустороння связь **фиксированного размера**, но возможно 
различного для каждого узла. Связанные узлы периодически посылают друг другу пульсации, пир получении которых время последней связи с 
отправителем обновляется (а также при любом другом сетевом взамодействии). Также, периодически, узлы посылают друг другу свои 
списки соседей. При получении такого списка, узел соединяет его со своим, сортирует по возрастанию времени последней связи, 
и оставлет начало списка, которое укладывается в его размер.

Утверждается, что при достаточно большом количестве узлов сеть, построенная по этому принципу будет образовывать техническую социальную сеть.
В ней будут единичные хабы, с большим количеством связей, тогда как большинство будут иметь связей гораздо меньше. Распределение размеров списков
связей (т.е. степеней вершин в графе, представляющих сеть) будет стремиться к степенному, свойственному технических сетям. Маленький диаметр, свойственый
таким сетям будет способствовать скорейшему распростарнению информации. При периодическои обновлении списков соседних узлов естественным же образом 
будут удалятся недоступные узлы, а сами узлы и подключения будут сремиться к образованию, топологии близкой к минимальному остову. По причине того что в 
списках соседей вероятнее будут оказываться узлы, с которыми сообщение ведется чаще, соединения будут также локализовываться по принципу частоты 
взаимодействия.

[Некоторые эксперименты](../apps/noma_peer_sampling) подтверждают описанные утверждения.

Описанный алгоритм прост до банальности, и очевидно, не лишен (в том числе фатальных) недостатков. Однако снабдив его некоторыми эвристиками, 
для повышения отказоустойчивости получим (гораздо более сложный) HyParView. Проверенный и зарекомендовавший себя.

# Реализованный P2P на основе CAF

Если вы все ещё не знакомы c [CRDT](https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type), то это хороший шанс познакомиться. Здесь и далее многое зависит это этих структур данных.

Крако - CRDT это класс структур данных, поддердивающих 2 операции: обновление и безконфликтное слияние. δ-CRDT - это подкласс CRDT, которые могут обмениваться лишь частью своего состояния при слиянии.

* В проекте реализован альтернативный слой [TCP транспорта](../tcp), базирующийся на boost.ASIO, а также основанный на нем  [http сервер](../apps/http).

* Поверх него создан модуль [remoting] , позволяющий обмениваться сообщениями акторам CAF, так, если бы они находились локально. Т.е. инкапсулирующий работу с сетью. Построен по принципу [proxy/stub](https://pp.userapi.com/c837439/v837439897/22d21/TyH39SUkBh4.jpg)

* В довершении создан модуль [clustering](../clustering), являющийся квинтессенцией алгорима, используемого в Akka.Cluster. Узлы хранят у себя некую структур, содержащюю адреса узлов, **входящих в кластер**, т.е. таких. о которых известно, 
что другие знают о том что они входят в кластер. Сама структура представляет из себя CRDT AWORSet - множество, которое поддерживает параллельную вставку/удаление 
и безконфлиткное слияние. Узлы периодически синхронизируют друг с другом свои списки, и если один узел потерял с другим связть, он удаляет его из своего списка, и в дальнейшем он 
транзитивно удалится из списков со всех узлов.
С proof-of-concept реализацией можно ознакомиться [clustering](../clustering).
Заменив AWORSet на AWORMap, и полагая, что значение в это map будет количество голосов за исключение ноды из кластера (или более сложной структуры, учитывающей состояние)
получим простейшую реализаци алгоритма, используемого, например в Akka.Cluster.

* С принципми работы этих модулей можно ознакомится в тестах [TCP](../tests/src/CAF_TCP_basic_tests.cpp) [remoting](../tests/src/remoting.cpp) [clustering](../tests/src/clustering.cpp).

* Также приведены несколько демонстрационных приложений [node_random_add](../apps/node_random_add) и [nomadb](../apps/nomadb)

[Далее Консенсус](Consensus.md)